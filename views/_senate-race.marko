var race=data.model.race

li.${race.dem_win_prob_with_undecided > 0.5 ? 'lean-dem' : (race.dem_win_prob_with_undecided == 0.5 ? 'toss-up' : 'lean-gop')} data-state-code="${race.state_code}"
  input.expand#state-race-expand-${race.state_code} data-state-code="${race.state_code}" type="checkbox" value="${race.state_code}"

  .content-to-expand
    label.state-code for="state-race-expand-${race.state_code}" - ${race.state_code}

    label.probability for="state-race-expand-${race.state_code}"
      span.box
        span.marker style="left: ${100 * (1 - race.dem_win_prob_with_undecided)}%"

    .details
      var o=race.calculations
      h4
        if(o.tie)
          strong.probability - Toss-up
          -  in ${race.state_name}
        else
          strong.probability - ${o.prob_with_undecided}%
          -  chance ${race.state_name} will 
          span.flip-or-stay - ${race.flip_prob > .5 ? 'flip to' : 'remain with'}
          -  a 
          span.party - ${o.winner_party_full}
      if(!race.curve.is_plottable)
        ol.calculations
          li - Since we haven't collected enough polls, we rely on Cook Political Report's <a href="http://cookpolitical.com/senate/charts/race-ratings">Senate Ratings</a>.
          li - <em>Cook</em> suggests ${race.state_name}'s senate race is <strong class="cook-rating">${race.cook_rating_name}</strong>.
          if(!o.tie)
            li - Historically, Cook has been right about this call in ${o.raw_prob}% of Senate races.
      else
        ol.calculations
          if(o.tie)
            li - Our simulations ended in a <span class="undecided">tie</span> between <span class="dem">${race.dem_name} (D)</span> and <span class="gop">${race.gop_name} (R)</span>.
          else
            li - <span class="${o.winner_party}">${o.winner_name} (${o.winner_party_letter})</span> won against <span class="${o.loser_party}">${o.loser_name} (${o.loser_party_letter})</span> in <strong>${o.raw_prob}%</strong> of our simulations.
            li - Our simulated populations were <span class="undecided">${o.undecided}% undecided</span> on average. We penalized the winner's chances by <strong>${o.undecided_penalty}</strong> ${o.undecided_penalty == 1 ? 'percentage point' : 'percentage points'}. Our adjusted probability is <span class="${o.winner_party}">${o.prob_with_undecided}% ${o.winner_party_full}</span>.

        .chart-container
          .y-axis-and-rest
            .y-axis
              .label - Percentage<br>Point Lead
              .values
                .max-dem - D+${race.curve.y_max * 100}
                .mid-dem - D+${race.curve.y_max * 50}
                .zero - 0
                .mid-gop - R+${race.curve.y_max * 50}
                .max-gop - R+${race.curve.y_max * 100}
            .rest
              .x-axis
                .start-date - July 1
                .arrow
                .end-date - Nov. 8
                .label-election-day - Election Day
              .plot
                svg.plot viewBox="0 0 1000 600"
                  rect.dem x="0" y="0" width="1000" height="300"
                  rect.gop x="0" y="300" width="1000" height="300"
                  path.x-axis d="M0,300H1000"
                  if(race.curve.updated_at_x != race.curve.x_max)
                    path.x-updated-at d="M${Math.round(race.curve.date_width * race.curve.updated_at_x)},0V600"
                  path.diff d="${race.curve.svg_path('diff_xibar')}"
                  path.sample d="${d}" for(d in race.curve.calculate_sample_svg_paths())
                  circle.poll.${pt.html_class} cx="${pt.x}" cy="${pt.y}" r="8" for(pt in race.curve.calculate_poll_coordinates())
              <!-- always show ".today", for sizing; but leave it empty after election day. -->
              .today
                if(race.curve.updated_at_x != race.curve.x_max)
                  .today-inner style="right: ${100 * (1 - race.curve.updated_at_x / (race.curve.NDays - 1))}%"
                    .label - Latest Average
                    .date-and-spread
                      time datetime="${race.curve.updated_at.toISOString()}" - ${data.helpers.format_date(race.curve.updated_at)}
                      strong.spread - $!{race.curve.today_spread_html()}

        .legend - Our algorithm simulates 5,000TK <span class="legend-def"><svg class="legend-image legend-thread" viewBox="0 0 100 50"><path d="M0,40 l 2,3 2,-3 2,-5 2,-5 2,0 2,-1 2,-3 2,20 2,-7 2,-3 2,-7 2,1 2,1 2,-3 2,-4 2,1 2,0 2,1 2,-3 2,1 2,-3 2,-3 2,0 2,2 2,-5 2,14 2,-3 2,10 2,-2 2,4 2,-5 2,-7 2,1 2,-3 2,-4 2,1 2,0 2,1 2,-3 2,1 2,-3 2,-3 2,0 2,2 2,-5 2,8 2,-3 2,1 2,-2"/></svg> random populations</span> that vote similarly to <span class="legend-def"><svg class="legend-image legend-poll" viewBox="0 0 50 50"><circle cx="25" cy="25" r="15"/></svg> poll results</span>. For illustration, we plot 200TK populations and show the <span class="legend-def"><svg class="legend-image legend-average" viewBox="0 0 100 50"><path d="M0,10 l 10,1 10,2 10,5 10,10 10,-2 10,-4 10,0 10,1 10,1 10,1"/></svg> average</span>.
