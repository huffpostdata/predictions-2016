var races=data.model.races

#senate-races
  h2 - State By State

  p - Our algorithm simulates 5,000TK random populations who conform to poll results. It counts how many populations vote Republican and how many populations vote Democrat on election day.

  p - The 2016 Senate consists of 54 Republicans and 46 Democrats. (The two independent senators caucus with Democrats.) If two states flip from Republican to Democratic and all other states stay consistent, the 2017 Senate will be split 50-50.

  .container
    .axis-50
    ul
      li data-state-code="${race.state_code}" for(race in races.sorted_by('flip-probability'))
        .state-code - ${race.state_code}
        .probability.${race.dem_win_prob_with_undecided > 0.5 ? 'lean-dem' : (race.dem_win_prob_with_undecided == 0.5 ? 'toss-up' : 'lean-gop')}
          .box
            .marker style="left: ${100 * (1 - race.dem_win_prob_with_undecided)}%"

          .details
            .arrow style="left: ${100 * (1 - race.dem_win_prob_with_undecided)}%"
            h4
              span.incumbent-party.${race.seat_party_code}
              span.state - ${race.state_code}
              - : 
              span.prob - ${Math.round(100 * race.flip_prob)}%
              -  chance to flip to ${race.flip_party_code}
            if(race.curve.is_plottable)
              ol.calculations
                var o=race.calculations
                if(o.tie === 0.5)
                  li - Our simulations ended in a <span class="undecided">tie</span> between <span class="dem">${race.dem_name} (D)</span> and <span class="gop">${race.gop_name} (R)</span>.
                else
                  li - In our simulations, <span class="${o.winner_party}">${o.winner_name} (${o.winner_party_letter})</span> won against <span class="${o.loser_party}">${o.loser_name} (${o.loser_party_letter})</span> <strong>${o.raw_prob}%</strong> of the time.
                  li - Our simulations also show that the polled population is <span class="undecided">${o.undecided}% undecided</span>. We penalized the winner by <strong>${o.undecided_penalty}</strong> ${o.undecided_penalty == 1 ? 'percentage point' : 'percentage points'}. Our adjusted probability is <span class="${o.winner_party}">${o.prob_with_undecided}% ${o.winner_party_full}</span>.

              .chart-container
                .y-axis-and-rest
                  .y-axis
                    .label - Percentage<br>Point Lead
                    .values
                      .max-dem - D+${race.curve.y_max * 100}
                      .mid-dem - D+${race.curve.y_max * 50}
                      .zero - 0
                      .mid-gop - R+${race.curve.y_max * 50}
                      .max-gop - R+${race.curve.y_max * 100}
                  .x-axis-and-plot-and-today
                    .x-axis
                      .start-date - July 1
                      .arrow
                        svg.arrow viewBox="0 0 99 7" preserveAspectRatio="none"
                          path d="M0,3h96L95.5,0L99,3.5L95.5,7L96,4h-96z"
                      .end-date - Nov. 8
                      .label-election-day - Election Day
                    .plot
                      svg.plot viewBox="0 0 1000 600"
                        rect.dem x="0" y="0" width="1000" height="300"
                        rect.gop x="0" y="300" width="1000" height="300"
                        path.x-axis d="M0,300H1000"
                        if(race.curve.updated_at_x != race.curve.x_max)
                          path.x-updated-at d="M${Math.round(race.curve.date_width * race.curve.updated_at_x)},0V600"
                        path.diff d="${race.curve.svg_path('diff_xibar')}"
                        path.sample d="${d}" for(d in race.curve.calculate_sample_svg_paths())
                        circle.poll.${pt.html_class} cx="${pt.x}" cy="${pt.y}" r="8" for(pt in race.curve.calculate_poll_coordinates())
                    <!-- always show ".today", for sizing; but leave it empty after election day. -->
                    .today
                      if(race.curve.updated_at_x != race.curve.x_max)
                        .today-inner style="right: ${100 * (1 - race.curve.updated_at_x / (race.curve.NDays - 1))}%"
                          .label - Latest Average
                          .date-and-spread
                            time datetime="${race.curve.updated_at.toISOString()}" - ${data.helpers.format_date(race.curve.updated_at)}
                            strong.spread - $!{race.curve.today_spread_html()}

              .legend - We simulated 5,000TK <span class="legend-def"><svg class="legend-image legend-thread" viewBox="0 0 100 50"><path d="M0,40 l 2,3 2,-3 2,-5 2,-5 2,0 2,-1 2,-3 2,20 2,-7 2,-3 2,-7 2,1 2,1 2,-3 2,-4 2,1 2,0 2,1 2,-3 2,1 2,-3 2,-3 2,0 2,2 2,-5 2,14 2,-3 2,10 2,-2 2,4 2,-5 2,-7 2,1 2,-3 2,-4 2,1 2,0 2,1 2,-3 2,1 2,-3 2,-3 2,0 2,2 2,-5 2,8 2,-3 2,1 2,-2"/></svg> random populations</span> that conform to <span class="legend-def"><svg class="legend-image legend-poll" viewBox="0 0 50 50"><circle cx="25" cy="25" r="15"/></svg> polls</span>. (We only plot 200TK.) For illustration, we show their <span class="legend-def"><svg class="legend-image legend-average" viewBox="0 0 100 50"><path d="M0,10 l 10,1 10,2 10,5 10,10 10,-2 10,-4 10,0 10,1 10,1 10,1"/></svg> average</span>.
